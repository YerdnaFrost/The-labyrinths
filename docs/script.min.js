function adjustScale(){const content=document.body;const baseWidth=400;const baseHeight=700;const targetScale=1.2;const windowWidth=window.innerWidth;const windowHeight=window.innerHeight;const scaleX=windowWidth/baseWidth;const scaleY=windowHeight/baseHeight;const maxScale=Math.min(scaleX,scaleY);const actualScale=Math.min(targetScale,maxScale);content.style.transform=`scale(${actualScale})`;content.style.transformOrigin='center top';}const PASSWORD="00000";const MAX_ATTEMPTS=5;let attempts=0;let currentPassword="";function addDigit(digit){if(currentPassword.length<5){currentPassword+=digit;updatePasswordDisplay();if(currentPassword.length===5){checkPassword();}}}function deleteDigit(){if(currentPassword.length>0){currentPassword=currentPassword.slice(0,-1);updatePasswordDisplay();}}function clearDigits(){currentPassword="";updatePasswordDisplay();}function updatePasswordDisplay(){const digits=document.querySelectorAll('.password-digit');digits.forEach((digit,index)=>{digit.textContent=index<currentPassword.length ? currentPassword[index]:'•';});}function checkPassword(){if(currentPassword===PASSWORD){document.getElementById('passwordScreen').style.display='none';document.getElementById('mainScreen').style.display='block';initGame();}else{attempts++;currentPassword="";updatePasswordDisplay();const errorElement=document.getElementById('passwordError');errorElement.classList.add('visible');if(attempts>=MAX_ATTEMPTS){document.body.innerHTML='<div style="text-align:center;padding:50px;font-size:24px;color:#ff4444;">Доступ заблокирован</div>';}}}function initPasswordKeyboard(){const numpad=document.getElementById('numpad');const clearButton=document.getElementById('clearButton');const deleteButton=document.getElementById('deleteButton');numpad.querySelectorAll('[data-digit]').forEach(button=>{button.addEventListener('click',()=>{addDigit(button.getAttribute('data-digit'));});});clearButton.addEventListener('click',clearDigits);deleteButton.addEventListener('click',deleteDigit);}function initGame(){const mazeData=[ [ "010101111110100100","111100010011111110","010111111010101011","010000011110100001","111111001010101011","100011101000111001","110110101101101111","000000101000100010","111111111111101111","010010001101100100","010111100100111101","110000110110000111","011110100011111100","000100111001000101","110110001101110101","010111111100011111","111101100101001001","110100110111111101" ],[ "110111001001101011","010101111101001001","111101010111111101","110001000000100111","100111111111110010","110101000010010111","010001000111010101","111011110001000101","001110111011111100","101000001010001001","111010101111101111","101110100010101001","001011111110001100","111000101011111110","110011100010101011","010110101111101000","110010001001001111","111111111101011010" ],[ "000110100100110101","010010101110100111","110110111011110100","010100100010011111","011111110111001011","110101010001011110","100001011101010011","111101000111111010","010111010101001011","010001011101101010","111011110001001110","100000010101011011","111111111111011110","010001000101110011","111011111100110110","010001010110011100","011111000111110111","110101011100100101" ],[ "011111010101100111","000101110101111101","111101010100100100","000101110111110111","011100010100011100","010111010101110111","110001111100100101","111111010001110111","100011011111000110","111010000101010010","001010101101010111","111011111001010100","101110101011111110","100010001010000010","110111111010101111","010101010011101011","010100010110100010","111110111100111111" ],[ "111001110101111111","101101010100010001","001001011111111011","101111001010001001","111001100010101101","010011111010100111","110110001010111101","010010101110101001","111110101011101111","100010111000001001","110111101110111011","010110000100010000","010100111111111101","111101100001010111","000100101101000100","011111101001011111","110010111101001010","011010010111100011" ] ];let history=[];let currentState=null;function deepCopyState(state){const copy={mazes:[]};for(const mazeState of state.mazes){const mazeCopy={cells:JSON.parse(JSON.stringify(mazeState.cells)),paths:[]};for(const path of mazeState.paths){const pathCopy={cells:new Map(path.cells),sources:new Set(path.sources),treasures:new Set(path.treasures),closeCells:new Set(path.closeCells)};mazeCopy.paths.push(pathCopy);}copy.mazes.push(mazeCopy);}return copy;}function restoreState(copy){currentState=deepCopyState(copy);}function saveSnapshot(){history.push(deepCopyState(currentState));}function init(){currentState={mazes:[]};for(let i=0;i<mazeData.length;i++){const maze=mazeData[i];const rows=maze.length;const cols=maze[0].length;const mazeState={cells:[],paths:[]};for(let y=0;y<rows;y++){const row=[];for(let x=0;x<cols;x++){row.push({isWall:maze[y][x]==='0',isPath:maze[y][x]==='1'});}mazeState.cells.push(row);}for(let y=0;y<rows;y++){for(let x=0;x<cols;x++){if(maze[y][x]==='1'){mazeState.paths.push({cells:new Map([[`${x},${y}`,'current']]),sources:new Set(),treasures:new Set(),closeCells:new Set()});}}}currentState.mazes.push(mazeState);}history=[];renderAllMazes();updateStats();}function renderAllMazes(){for(let i=0;i<mazeData.length;i++){renderMaze(i);}}function getCellColor(mazeState,x,y){const cell=mazeState.cells[y][x];if(cell.isWall)return 'wall';const key=`${x},${y}`;let hasPossible=false;let hasSource=false;let hasVisited=false;let hasTreasure=false;let hasClose=false;for(const path of mazeState.paths){const type=path.cells.get(key);if(type==='current')hasPossible=true;if(path.sources.has(key))hasSource=true;if(type==='visited')hasVisited=true;if(path.treasures.has(key))hasTreasure=true;if(path.closeCells.has(key))hasClose=true;}if(hasPossible)return 'possible';if(hasClose)return 'close';if(hasTreasure)return 'treasure';if(hasSource)return 'source';if(hasVisited)return 'visited';return 'path';}function renderMaze(mazeIndex){const mazeElement=document.getElementById(`maze-${mazeIndex}`);const mazeState=currentState.mazes[mazeIndex];if(!mazeElement)return;mazeElement.innerHTML='';const rows=mazeState.cells.length;const cols=mazeState.cells[0].length;mazeElement.style.gridTemplateColumns=`repeat(${cols},10px)`;for(let y=0;y<rows;y++){for(let x=0;x<cols;x++){const cell=document.createElement('div');cell.className='cell';cell.classList.add(getCellColor(mazeState,x,y));mazeElement.appendChild(cell);}}}function findActiveMaze(){for(let i=0;i<currentState.mazes.length;i++){const mazeState=currentState.mazes[i];for(const path of mazeState.paths){for(const [key,type] of path.cells){if(type==='current'){return{mazeState,mazeIndex:i};}}}}return null;}function updateStats(){const activeMazeInfo=findActiveMaze();let cellsPassed=0;let treasureCollected=0;if(activeMazeInfo){const activeMazeState=activeMazeInfo.mazeState;let activePath=null;for(const path of activeMazeState.paths){for(const [key,type] of path.cells){if(type==='current'){activePath=path;break;}}if(activePath)break;}if(activePath){for(const [key,type] of activePath.cells){if(type==='visited'){cellsPassed++;}}treasureCollected=activePath.treasures.size;cellsPassed++;}}document.getElementById('cells-passed').textContent=`Пройдено клеток:${cellsPassed}`;document.getElementById('treasure-collected').textContent=`Собрано добычи:${treasureCollected}`;}function move(direction){saveSnapshot();let totalActivePaths=0;let hasInvalidMove=false;for(let i=0;i<mazeData.length;i++){const mazeState=currentState.mazes[i];const maze=mazeData[i];const rows=maze.length;const cols=maze[0].length;const newPaths=[];for(const path of mazeState.paths){let currentX,currentY,currentKey;for(const [key,type] of path.cells){if(type==='current'){[currentX,currentY]=key.split(',').map(Number);currentKey=key;break;}}if(currentX===undefined || currentY===undefined)continue;let newX=currentX;let newY=currentY;switch(direction){case 'north':newY--;break;case 'south':newY++;break;case 'west':newX--;break;case 'east':newX++;break;}if(newX>=0 && newX<cols && newY>=0 && newY<rows && maze[newY][newX]==='1'){const newPath={cells:new Map(path.cells),sources:new Set(path.sources),treasures:new Set(path.treasures),closeCells:new Set(path.closeCells)};newPath.cells.set(currentKey,'visited');newPath.cells.set(`${newX},${newY}`,'current');newPaths.push(newPath);}else{hasInvalidMove=true;}}mazeState.paths=newPaths;totalActivePaths+=newPaths.length;}if(totalActivePaths===0 && hasInvalidMove){alert("Вы определённо упёрлись в стену. Возвращаемся к предыдущему состоянию.");undo();return;}renderAllMazes();updateStats();}function setSource(){saveSnapshot();for(let i=0;i<currentState.mazes.length;i++){const mazeState=currentState.mazes[i];for(const path of mazeState.paths){let currentKey=null;for(const [key,type] of path.cells){if(type==='current'){currentKey=key;break;}}if(currentKey){path.sources.add(currentKey);}}}renderAllMazes();updateStats();}function setTreasure(){saveSnapshot();for(let i=0;i<currentState.mazes.length;i++){const mazeState=currentState.mazes[i];for(const path of mazeState.paths){let currentKey=null;for(const [key,type] of path.cells){if(type==='current'){currentKey=key;break;}}if(currentKey){path.treasures.add(currentKey);}}}renderAllMazes();updateStats();}function setClose(){saveSnapshot();for(let i=0;i<currentState.mazes.length;i++){const mazeState=currentState.mazes[i];for(const path of mazeState.paths){let currentKey=null;for(const [key,type] of path.cells){if(type==='current'){currentKey=key;break;}}if(currentKey){path.closeCells.add(currentKey);}}}renderAllMazes();updateStats();}function undo(){if(history.length>0){restoreState(history.pop());renderAllMazes();updateStats();}}function reset(){history=[];init();}init();document.getElementById('north').addEventListener('click',()=>move('north'));document.getElementById('south').addEventListener('click',()=>move('south'));document.getElementById('west').addEventListener('click',()=>move('west'));document.getElementById('east').addEventListener('click',()=>move('east'));document.getElementById('close').addEventListener('click',setClose);document.getElementById('set-source').addEventListener('click',setSource);document.getElementById('set-treasure').addEventListener('click',setTreasure);document.getElementById('undo').addEventListener('click',undo);document.getElementById('reset').addEventListener('click',reset);}window.onload=function(){document.getElementById('passwordScreen').style.display='flex';document.getElementById('mainScreen').style.display='none';initPasswordKeyboard();adjustScale();};window.addEventListener('resize',adjustScale);